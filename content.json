{"pages":[],"posts":[{"title":"1.机器语言与机器指令","text":"机器语言和机器指令机器语言就是机器指令的集合。机器指令是一条集算计可以正确执行的命令，机器指令由一串二进制数表示，比如说 00100100，但是如果让我们手动的去写这种机器指令的话，一旦写错估计需要个把月才能找到程序到底错那了，而这时出现了汇编语言。 汇编语言汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上，汇编指令其实就是机器指令便于记忆的书写格式，是机器指令的助记符。比如说： 12345机器指令：10010011010101操作： 将寄存器BX的内容送到AX中汇编指令：MOV AX,BX 实现了相同的功能，但是对于我们来讲汇编指令易懂并且便于记忆。 上面的介绍中提到，汇编指令其实就是机器指令的一种书写格式而已，实际上还是机器指令，当我们编写汇编指令时，会通过编译器将我们的汇编指令写成的源程序编译成机器码，然后才会交给计算机进行执行。 12345graph LRA[程序员]--编写--&gt;B[汇编指令];B--&gt;C[编译器];C--编译--&gt;D[机器指令];D--执行--&gt;F[计算机]; 汇编指令又分为汇编指令、伪指令和其他符号： 汇编指令也就是机器码的助记符，其会通过编译器转成机器指令交给计算机执行的 伪指令本身不是计算机能够直接执行的，它会在当汇编指令通过编译器转机器码的过程中执行。 其他符号也由编译器执行123456789101112assume cs:codesg // 伪指令codesg segmentstart: // 其他符号 mov ax,0123H // 汇编指令 mov bx,0456H add ax,bx add ax,ax mov ax,4c00h int 21hcodesg endsend","link":"/2020/12/30/1.%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/"},{"title":"2.计算机的组成","text":"“解刨” 计算机计算机的核心就是主板，主板上有： CPU(中央处理器) 总线(在多个部件之间进行传输数据、传输指令) 内存(工作过程中保存数据) 拓展槽(连接外部设备,比如说显示器、打印机) CPUCPU是计算机的核心部件，它控制整个计算机的运作并进行运算。想要让一个CPU工作，就必须向他提供指令和数据。而指令和数据会放在存储器中(内存)，所以离开了内存，性能再好的CPU也无法工作。 指令和数据的表示计算机中是数据和指令，都会存储在内存或者磁盘上(也可以叫外存)。当永久性存储时会将数据和指令存储在磁盘上，但是当计算机在开始运行时CPU中所需用到数据就都必须从磁盘中读取到内存中，然后由CPU和内存进行交互执行。数据和指令都是二进制信息，那么10011010110是指令还是数据呢？它可以是指令也可以是数据，具体是什么就看CPU怎么用它。 数据的表示： 示例 解释 1001B 二进制数，由B作为后缀 89D8H 十六进制数，由H作后缀或者0x为前缀 1007O 八进制数，由0作为后缀 3627D 十进制数，由D作为后缀 数据量：B、KB、MB、GB、TB、PB… 1024B = 1KB 1024KB = 1MB … 以 1024 为进制。 存储单元不管是数据还是指令都要存放到存储器(内存)中，而存储器被划分为若干个存储单元，每个存储单元中存放一个字节的数据(0000 0000),每个存储单元从0开始顺序编号；假设一个存储器有 128 个存储单元，那么他的编号就是 0 ~ 127 如下示例： 编号 存储单元 0 1 2 … 127 上面的表格表示了一个拥有 128 个存储单元的内存模拟图，而实际上内存空间很”大”,8086处理器的有20条数据线，寻址空间也就是2的20次方，也就是1MB,那么他的模拟图就是这样的： 编号 存储单元 0 1 2 … FFFFFH 注：1个F最大就是15，而2进制中15表示 0000 ，所以 5个F就是 0000 0000 0000 0000 0000。 计算机中的总线：在计算机中专门有链接CPU和其他芯片的导线，通常称为总线。总线在物理上就是一根一根的导线的集合。总线在逻辑上又分为： 地址总线 数据总线 控制总线 地址总线：CPU是通过地址总线来指定存储单元的。所以地址总线的宽度，决定了可寻址的存储单元大小。有N根地址总线(宽度为N)，那么对应的寻址空间就是2的N次方。 比如说，地址总线的宽度是4，也就是有4根导线是作为地址总线使用的，那么他一次最多只能传输最大的地址就是15(0000)。 假设你的CPU有16根地址总线，那么你的寻址空间就是2的16次方也就是64kb。 数据总线CPU与内存或者其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。 比如说：数据总线的宽度是4，我一次性能够传递 0000 ，也就是4个二进制位的数出去，最大依然是15，那么假如我要传输个16怎么办，我是不是要分两次传，传两次肯定比传一次慢，所以数据总线的宽度决定了CPU和外界数据传送的速度。 控制总线CPU通过控制总线对外部器件进行控制。控制总线是一些不同控制线的集合，控制总线的宽度决定了CPU对外部器件的控制能力。","link":"/2020/12/30/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%BB%84%E6%88%90/"},{"title":"3.内存读写与内存空间","text":"CPU对存储器的读写CPU想要进行数据的读写，必须和外部期间进行三类信息的交互： 存储单元的地址(地址信息) 也就是你要在什么地方操作 器件的选择，读或写命令(控制信息) 也就是你要在存储单元上干什么，读或者写 读或写的数据(数据信息) 你要操作什么数据 比如说，我要在 0xF(地址信息) 这个地址的存储单元上写入(控制信息) 0xF1(数据信息) 的数据。那么他的流程大概就是这样的： CPU读取我们的地址信息 0xF 然后通过地址总线找到内存中这个地址指向的存储单元 通过控制总线进行控制读或者写的操作，我们这里是写入，所以就是发出写的操作指令 通过数据总线把数据给出去 内存地址空间从上面CPU对存储器的操作中发现，我们对存储单元的读写会通过地址总线找到相应的地址，那么这个地址是如何找到的呢？这时候就引出了内存地址空间的概念。 CPU地址总线宽度为N，寻址空间就是2的N次方的字节。8086CPU的地址总线为20，它可以寻址1M个内存单元，这1MB个可寻到的内存单元就构成这个CPU的内存地址空间。 从CPU角度看地址空间分配： RAM(随机存储器) 特点：能读能写，缺点就是当机器一断电，里面的信息就会全部丢失，一般 RAM 存储的数据就是在计算机运行时动态变化的数据 RAM有很多种类，主要有插入主板上的RAM和拓展槽上的RAM(比如显卡) ROM(只读存储器) 只能从里面读数据，而不能进行写数据，它里面的数据是在造计算机时就已经写好了，相当于在制造计算机时在里面定义了很多 final 的常量，一般存储在计算器启动时就需要用的数据或者在使用时固定的不变的数据。 主要是系统BIOS，接口卡上的BIOS 在上图中，有绿色底座的代表插在拓展槽上的存储器，没有绿色底座的代表插在主板上的存储器 现在我们将各类存储器看作为一个逻辑存储器，也就是我们把它们想象成一个整体，然后进行统一编址(存储地址)，多个物理存储器我们把它们看作一个其中由若干存储单元组成的逻辑存储器。每个物理存储器在这个逻辑存储器中占有一个地址段，也就是一段地址空间。 这个时候我们就不需要考虑我们要操作什么设备的什么地址了，直接说你要操作什么地址，自然那个地址就是相应的存储器的。 比如说：有内存还有显存，那么把它们想象成一个整体，其中内存占有位置从0-15，显存占有位置16-30，那么现在我说我要读写内存地址为17的主存储器，那么是不是自然而然就知道我是要操作显存而不是内存。 在上图中，我们把各种类型RAM、ROM，都看作一个整体，每个存储器又占有一段地址空间，当我们操作具体某个地址段时自然而然就知道是在操作谁。 8086系统案例： 注：BIOS 就是固化到ROM芯片的程序，保存着计算机最重要、最基本的输入输出程序，系统自启动，自检程序，为计算机提供了最底层的，最直接的硬件设置和控制。此外还向作业系统提供了一些系统参数。系统硬件的变化是由BIOS隐藏，程序使用BIOS功能而不是直接控制硬件。现代作业系统会忽略BIOS提供的抽象层并直接控制硬件组件。 来源：https://baike.baidu.com/item/bios/91424","link":"/2020/12/30/3.%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E4%B8%8E%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/"},{"title":"4.寄存器与数据存储","text":"CPU的组成CPU中由运算器进行信息处理，这个运算器主要指的是 ALU 算术逻辑单元 CPU通过 BUS 总线，来和内存进行交互 CPU工作时由寄存器进行信息存储，图中，橘黄色以及青色就是我们这里讲的寄存器。寄存器就是计算机内部用来存储数据的单元。 由控制器进行协调各种器件进行工作，图中，亮黄色与绿色就是这里讲的控制器。 由内部总线实现CPU内，各个器件之间的联系。 寄存器8086CPU有14个寄存器，分别是： 通用寄存器：AX、BX、CX、DX 变址寄存器：SI、DI 指令指针寄存器：IP 指针寄存器：SP、BP 段寄存器：CS、SS、DS、ES 标志寄存器: PSW 它们的共性：8086CPU所有的寄存器都是 16 位的，也就是可以存放两个字节的数据。 通用寄存器-以AX为例一个16位的寄存器可存储一个16位的数据，**所以它能够存储的最大值就是2的16次方**-1 比如说: 我们在AX中存储 18D 的数据，D代表十进制的数，也就是 10010B 寄存器兼容性问题刚才举例使用了 8086CPU ，它所使用的寄存器是16位的，但是8086上一代CPU中的寄存器都是8位的，如何保证程序的兼容性是一个问题，总不能说我以前写的程序，你更新了一下系统我全部白干了对吧。 现代计算机的解决方案：通用寄存器均可以分为两个独立的8位寄存器使用，也就是1个AX(16位寄存器)内部可以分为AH和AL，两个8位的寄存器，其中AH代表了高8位，AL代表了低8位，当读写AH时就代表了向AX的高八位进行读写，如果读写AL时就代表向AX的第八位进行读写。 注意：这里讲的可以分为两个独立的8位寄存器使用只是我们把一个16位的高8位和低8位看成两个8位的寄存器，而不是16寄存器由两个8位寄存器组成！ 比如说： 图中，向AX中存入了一个 20000D 十进制数，在AX中看到就是那么长的二进制数，但在AH中也就是AX的高八位中就是78D，在AL也就是AX的低八位看到就是32。这就相当于我有一个车库，有16个车位，我就可以它分为两个各有8个车位的车库租出去，当然也可以分为有4个车位的车库租出去，但是计算机中都是一个字节的存储，没有那存半个字节的。 所以通用寄存器中： AX可以分为 AH 和 AL BX可以分为 BH 和 BL CX可以分为 CH 和 CL DX可以分为 DH 和 DL 发现了吧，都是什么H，什么L结尾的，H其实代表的是 high(高) L就是 low(低) “字”在寄存器中的存储8086是16位的CPU，那么我们就可以说8086的**字长(word size)**是16位，所以说它是多少位的CPU，那么其实讲的就是它的字长是多少位的。 一个字(word)可以存在一个16位寄存器中，这个字的高位字节存在这个寄存器的高8位，这个字的地位字节存在这个寄存器的低8位寄存器","link":"/2020/12/30/4.%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"title":"6.MOV和ADD指令","text":"汇编指令 控制CPU完成的操作 用高级语言的语法描述 mov ax,18 将18送入AX AX = 18 mov ah,78 将78送入AH AH = 78 add ax,8 将寄存器AX中的数值加上8 AX = AX + 8 mov ax,bx 将寄存器BX中的数据送入寄存器AX AX = BX add ax,bx 将AX,BX 中的内容相加，结果存入AX中 AX = AX + BX 注意：汇编指令不区分大小写 小测：程序段中的指令 | 执行后AX的数据 | 执行后BX的数据 | 含义解析—|—|—|—mov ax,001AH | 001AH | 0000H | 将 001AH 送入 axmov bx,0026H | 001AH | 0026H | 将 0026H 送入 bxadd al,bl | 0040H | 0026H | 将 ax 的低八位与 bx 的低八位 相加并送入 ax 的低八位add ah,bl | 2640H | 0026H | 将 ax 的高八位与 bx 的低八位 相加并送入 ax 的高八位add bh,al | 2640H | 4026H | 将 bx 的高八位与 ax 的低八位 相加并送入 bx 的高八位mov ah,0 | 0040H | 4026H | 将 0 送入 ax 的高八位add al,85H | 00C5H | 4026H | 将 ax 的低八位与 85H 相加并送入 ax 的低八位add al,93H | 0058H | 4026H | 这里原结果是 85H + 93H = 158H 但是由于我们使用的是 al(ax的低八位)，而al也只是一个8位的寄存器，产生的进位也只能舍弃最终结果就是 58H 设原AX、BX中的值均为 0000H","link":"/2020/12/30/5.MOV%E5%92%8CADD%E6%8C%87%E4%BB%A4/"},{"title":"","text":"物理地址CPU访问内存单元时要给出内存单元的地址，","link":"/2020/12/30/6.%E7%A1%AE%E5%AE%9A%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"彻底搞懂 MySQL 事务的隔离级别","text":"简介：MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。 事前准备数据mysql&gt; create table city( -&gt; id int(10) auto_increment,&lt;/span&gt; -&gt; name varchar(30),&lt;/span&gt; -&gt; primary key (id)&lt;/span&gt; -&gt; )engine=innodb charset=utf8mb4;&lt;/span&gt; insert into city(name) values(&lt;span class=&quot;hljs-emphasis&quot;&gt;'武汉市'&lt;/span&gt;); mysql&gt; select * from city; +----+-----------+ | id | name | +----+-----------+ | 1 | 武汉市 | +----+-----------+ 事务并发可能出现的情况脏读（Dirty Read） 一个事务读到了另一个未提交事务修改过的数据 会话B开启一个事务，把id=1的name为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取id=1的name，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。（脏读只在读未提交隔离级别才会出现） 不可重复读（Non-Repeatable Read） 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现） 会话A开启一个事务，查询id=1的结果，此时查询的结果name为武汉市。接着会话B把id=1的name修改为温州市（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），此时会话A的事务再一次查询id=1的结果，读取的结果name为温州市。会话B再此修改id=1的name为杭州市，会话A的事务再次查询id=1，结果name的值为杭州市，这种现象就是不可重复读。 幻读（Phantom） 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现） 会话A开启一个事务，查询id&gt;0的记录，此时会查到name=武汉市的记录。接着会话B插入一条name=温州市的数据（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），这时会话A的事务再以刚才的查询条件（id&gt;0）再一次查询，此时会出现两条记录（name为武汉市和温州市的记录），这种现象就是幻读。 事务的隔离级别 MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。 MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。 隔离级别比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交 隔离级别对性能的影响比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交 由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。 读未提交（READ UNCOMMITTED） 在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。 可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。 读已提交（READ COMMITTED） 在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。 读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。 可重复读（REPEATABLE READ） 在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。 可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。 提问：为什么上了写锁（写操作），别的事务还可以读操作？ 因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。 可串行化（SERIALIZABLE） 各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。 隔离级别的实现原理 使用MySQL的默认隔离级别（可重复读）来进行说明。 每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。即通过回滚（rollback操作），可以回到前一个状态的值。 假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。 当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。 同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。 提问：回滚操作日志（undo log）什么时候删除？ MySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。 提问：什么时候不需要了？ 当系统里么有比这个回滚日志更早的read-view的时候。 查看当前会话隔离级别方式1命令：SHOW VARIABLES LIKE 'transaction_isolation'; mysql&gt; show variables like 'transaction_isolation'; +-----------------------+--------------+&lt;/span&gt; | Variable_name | Value | +-----------------------+--------------+&lt;/span&gt; | transaction_isolation | SERIALIZABLE | +-----------------------+--------------+&lt;/span&gt;`&lt;/pre&gt; 方式2命令：SELECT @@transaction_isolation; mysql&gt; select @@transaction_isolation; +-------------------------+&lt;/span&gt; | @@transaction_isolation | +-------------------------+&lt;/span&gt; | SERIALIZABLE | +-------------------------+&lt;/span&gt;`&lt;/pre&gt; 设置隔离级别方式1：通过set命令SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level; 其中level有4种值： level: { REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE } 关键词：GLOBALSET GLOBAL TRANSACTION ISOLATION LEVELlevel; * 只对执行完该语句之后产生的会话起作用 * 当前已经存在的会话无效 关键词：SESSIONSET SESSION TRANSACTION ISOLATION LEVEL level; * 对当前会话的所有后续的事务有效 * 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务 * 如果在事务之间执行，则对后续的事务有效。 无关键词SET TRANSACTION ISOLATION LEVEL level; * 只对当前会话中下一个即将开启的事务有效 * 下一个事务执行完后，后续事务将恢复到之前的隔离级别 * 该语句不能在已经开启的事务中间执行，会报错的 方式2：通过服务启动项命令 可以修改启动参数transaction-isolation的值 比方说我们在启动服务器时指定了–transaction-isolation=READ UNCOMMITTED，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。","link":"/2020/12/30/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20MySQL%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"},{"title":"【干货】Chrome插件(扩展)开发全攻略","text":"写在前面我花了将近一个多月的时间断断续续写下这篇博文，并精心写下完整demo，所以转载务必保留 http://blog.haoji.me/chrome-plugin-develop.html 。本文所有涉及到的大部分代码均在这个demo里面：https://github.com/sxei/chrome-plugin-demo ，大家可以直接下载下来运行。 另外，本文图片较多，请耐心等待加载完毕。 本文目录： demo部分截图： 鉴于有很多网友有交流学习Chrome插件的诉求，所以最近建了一个插件开发交流群，仅仅是为了提供一个互相交流学习的平台： 仓库说明 full-chrome-plugin-demo：大部分demo代码都在这个仓库； simple-chrome-plugin-demo：最精简的Chrome仓库模板，当需要快速写一个简单仓库时可以基于这个模板； page-action-demo：关于page-action部分的demo代码，由于这部分代码和full-chrome-plugin-demo冲突，所以单独拿出来； 前言什么是Chrome插件严格来讲，我们正在说的东西应该叫Chrome扩展(Chrome Extension)，真正意义上的Chrome插件是更底层的浏览器功能扩展，可能需要对浏览器源码有一定掌握才有能力去开发。鉴于Chrome插件的叫法已经习惯，本文也全部采用这种叫法，但读者需深知本文所描述的Chrome插件实际上指的是Chrome扩展。 Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个.crx后缀的压缩包. 个人猜测crx可能是Chrome Extension如下3个字母的简写： 另外，其实不只是前端技术，Chrome插件还可以配合C++编写的dll动态链接库实现一些更底层的功能(NPAPI)，比如全屏幕截图。 由于安全原因，Chrome浏览器42以上版本已经陆续不再支持NPAPI插件，取而代之的是更安全的PPAPI。 学习Chrome插件开发有什么意义增强浏览器功能，轻松实现属于自己的“定制版”浏览器，等等。 Chrome插件提供了很多实用API供我们使用，包括但不限于： 书签控制； 下载控制； 窗口控制； 标签控制； 网络请求控制，各类事件监听； 自定义原生菜单； 完善的通信机制； 等等； 为什么是Chrome插件而不是Firefox插件 Chrome占有率更高，更多人用； 开发更简单； 应用场景更广泛，Firefox插件只能运行在Firefox上，而Chrome除了Chrome浏览器之外，还可以运行在所有webkit内核的国产浏览器，比如360极速浏览器、360安全浏览器、搜狗浏览器、QQ浏览器等等； 除此之外，Firefox浏览器也对Chrome插件的运行提供了一定的支持； 开发与调试Chrome插件没有严格的项目结构要求，只要保证本目录有一个manifest.json即可，也不需要专门的IDE，普通的web开发工具即可。 从右上角菜单-&gt;更多工具-&gt;扩展程序可以进入 插件管理页面，也可以直接在地址栏输入 chrome://extensions 访问。 勾选开发者模式即可以文件夹的形式直接加载插件，否则只能安装.crx格式的文件。Chrome要求插件必须从它的Chrome应用商店安装，其它任何网站下载的都无法直接安装，所以，其实我们可以把crx文件解压，然后通过开发者模式直接加载。 开发中，代码有任何改动都必须重新加载插件，只需要在插件管理页按下Ctrl+R即可，以防万一最好还把页面刷新一下。 核心介绍manifest.json这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，manifest_version、name、version3个是必不可少的，description和icons是推荐的。 下面给出的是一些常见的配置项，均有中文注释，完整的配置文档请戳这里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596{ // 清单文件的版本，这个必须写，而且必须是2 &quot;manifest_version&quot;: 2, // 插件的名称 &quot;name&quot;: &quot;demo&quot;, // 插件的版本 &quot;version&quot;: &quot;1.0.0&quot;, // 插件描述 &quot;description&quot;: &quot;简单的Chrome扩展demo&quot;, // 图标，一般偷懒全部用一个尺寸的也没问题 &quot;icons&quot;: { &quot;16&quot;: &quot;img/icon.png&quot;, &quot;48&quot;: &quot;img/icon.png&quot;, &quot;128&quot;: &quot;img/icon.png&quot; }, // 会一直常驻的后台JS或后台页面 &quot;background&quot;: { // 2种指定方式，如果指定JS，那么会自动生成一个背景页 &quot;page&quot;: &quot;background.html&quot; //&quot;scripts&quot;: [&quot;js/background.js&quot;] }, // 浏览器右上角图标设置，browser_action、page_action、app必须三选一 &quot;browser_action&quot;: { &quot;default_icon&quot;: &quot;img/icon.png&quot;, // 图标悬停时的标题，可选 &quot;default_title&quot;: &quot;这是一个示例Chrome插件&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; }, // 当某些特定页面打开才显示的图标 /*&quot;page_action&quot;: { &quot;default_icon&quot;: &quot;img/icon.png&quot;, &quot;default_title&quot;: &quot;我是pageAction&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; },*/ // 需要直接注入页面的JS &quot;content_scripts&quot;: [ { //&quot;matches&quot;: [&quot;http://*/*&quot;, &quot;https://*/*&quot;], // &quot;&lt;all_urls&gt;&quot; 表示匹配所有地址 &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;], // 多个JS按顺序注入 &quot;js&quot;: [&quot;js/jquery-1.8.3.js&quot;, &quot;js/content-script.js&quot;], // JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式 &quot;css&quot;: [&quot;css/custom.css&quot;], // 代码注入的时间，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle &quot;run_at&quot;: &quot;document_start&quot; }, // 这里仅仅是为了演示content-script可以配置多个规则 { &quot;matches&quot;: [&quot;*://*/*.png&quot;, &quot;*://*/*.jpg&quot;, &quot;*://*/*.gif&quot;, &quot;*://*/*.bmp&quot;], &quot;js&quot;: [&quot;js/show-image-content-size.js&quot;] } ], // 权限申请 &quot;permissions&quot;: [ &quot;contextMenus&quot;, // 右键菜单 &quot;tabs&quot;, // 标签 &quot;notifications&quot;, // 通知 &quot;webRequest&quot;, // web请求 &quot;webRequestBlocking&quot;, &quot;storage&quot;, // 插件本地存储 &quot;http://*/*&quot;, // 可以通过executeScript或者insertCSS访问的网站 &quot;https://*/*&quot; // 可以通过executeScript或者insertCSS访问的网站 ], // 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的 &quot;web_accessible_resources&quot;: [&quot;js/inject.js&quot;], // 插件主页，这个很重要，不要浪费了这个免费广告位 &quot;homepage_url&quot;: &quot;https://www.baidu.com&quot;, // 覆盖浏览器默认页面 &quot;chrome_url_overrides&quot;: { // 覆盖浏览器默认的新标签页 &quot;newtab&quot;: &quot;newtab.html&quot; }, // Chrome40以前的插件配置页写法 &quot;options_page&quot;: &quot;options.html&quot;, // Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个 &quot;options_ui&quot;: { &quot;page&quot;: &quot;options.html&quot;, // 添加一些默认的样式，推荐使用 &quot;chrome_style&quot;: true }, // 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字 &quot;omnibox&quot;: { &quot;keyword&quot; : &quot;go&quot; }, // 默认语言 &quot;default_locale&quot;: &quot;zh_CN&quot;, // devtools页面入口，注意只能指向一个HTML文件，不能是JS文件 &quot;devtools_page&quot;: &quot;devtools.html&quot;} content-scripts所谓content-scripts，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助content-scripts我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。 示例配置： 1234567891011121314151617{ // 需要直接注入页面的JS &quot;content_scripts&quot;: [ { //&quot;matches&quot;: [&quot;http://*/*&quot;, &quot;https://*/*&quot;], // &quot;&lt;all_urls&gt;&quot; 表示匹配所有地址 &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;], // 多个JS按顺序注入 &quot;js&quot;: [&quot;js/jquery-1.8.3.js&quot;, &quot;js/content-script.js&quot;], // JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式 &quot;css&quot;: [&quot;css/custom.css&quot;], // 代码注入的时间，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle &quot;run_at&quot;: &quot;document_start&quot; } ],} 特别注意，如果没有主动指定run_at为document_start（默认为document_idle），下面这种代码是不会生效的： 1234document.addEventListener('DOMContentLoaded', function(){ console.log('我被执行了！');}); content-scripts和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过injected js来实现。content-scripts不能访问绝大部分chrome.xxx.api，除了下面这4种： chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest) chrome.i18n chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage) chrome.storage 其实看到这里不要悲观，这些API绝大部分时候都够用了，非要调用其它API的话，你还可以通过通信来实现让background来帮你调用（关于通信，后文有详细介绍）。 好了，Chrome插件给我们提供了这么强大的JS注入功能，剩下的就是发挥你的想象力去玩弄浏览器了。 background后台（姑且这么翻译吧），是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。 background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。 经过测试，其实不止是background，所有的直接通过chrome-extension://id/xx.html这种方式打开的网页都可以无限制跨域。 配置中，background可以通过page指定一张网页，也可以通过scripts直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页： 123456789{ // 会一直常驻的后台JS或后台页面 &quot;background&quot;: { // 2种指定方式，如果指定JS，那么会自动生成一个背景页 &quot;page&quot;: &quot;background.html&quot; //&quot;scripts&quot;: [&quot;js/background.js&quot;] },} 需要特别说明的是，虽然你可以通过chrome-extension://xxx/background.html直接打开后台页，但是你打开的后台页和真正一直在后台运行的那个页面不是同一个，换句话说，你可以打开无数个background.html，但是真正在后台常驻的只有一个，而且这个你永远看不到它的界面，只能调试它的代码。 event-pages这里顺带介绍一下event-pages，它是一个什么东西呢？鉴于background生命周期太长，长时间挂载后台可能会影响性能，所以Google又弄一个event-pages，在配置文件上，它与background的唯一区别就是多了一个persistent参数： 1234567{ &quot;background&quot;: { &quot;scripts&quot;: [&quot;event-page.js&quot;], &quot;persistent&quot;: false },} 它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。 除了配置文件的变化，代码上也有一些细微变化，个人这个简单了解一下就行了，一般情况下background也不会很消耗性能的。 popuppopup是点击browser_action或者page_action图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。 popup可以包含任意你想要的HTML内容，并且会自适应大小。可以通过default_popup字段来指定popup页面，也可以调用setPopup()方法。 配置方式： 123456789{ &quot;browser_action&quot;: { &quot;default_icon&quot;: &quot;img/icon.png&quot;, // 图标悬停时的标题，可选 &quot;default_title&quot;: &quot;这是一个示例Chrome插件&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; }} 需要特别注意的是，由于单击图标打开popup，焦点离开又立即关闭，所以popup页面的生命周期一般很短，需要长时间运行的代码千万不要写在popup里面。 在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过chrome.extension.getBackgroundPage()获取background的window对象。 injected-script这里的injected-script是我给它取的，指的是通过DOM操作的方式向页面注入的一种JS。为什么要把这种JS单独拿出来讨论呢？又或者说为什么需要通过这种方式注入JS呢？ 这是因为content-script有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用content-script中的代码（包括直接写onclick和addEventListener2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？其实这就是本小节要讲的。 在content-script中通过DOM方式向页面注入inject-script代码示例： 123456789101112131415// 向页面注入JSfunction injectCustomJs(jsPath){ jsPath = jsPath || 'js/inject.js'; var temp = document.createElement('script'); temp.setAttribute('type', 'text/javascript'); // 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js temp.src = chrome.extension.getURL(jsPath); temp.onload = function() { // 放在页面不好看，执行完后移除掉 this.parentNode.removeChild(this); }; document.head.appendChild(temp);} 你以为这样就行了？执行一下你会看到如下报错： Denying load of chrome-extension://efbllncjkjiijkppagepehoekjojdclc/js/inject.js. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension. 意思就是你想要在web中直接访问插件中的资源的话必须显示声明才行，配置文件中增加如下： 1234{ // 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的 &quot;web_accessible_resources&quot;: [&quot;js/inject.js&quot;],} 至于inject-script如何调用content-script中的代码，后面我会在专门的一个消息通信章节详细介绍。 homepage_url开发者或者插件主页设置，一般会在如下2个地方显示： Chrome插件的8种展示形式browserAction(浏览器右上角)通过配置browser_action可以在浏览器的右上角增加一个图标，一个browser_action可以拥有一个图标，一个tooltip，一个badge和一个popup。 示例配置如下： 123456&quot;browser_action&quot;:{ &quot;default_icon&quot;: &quot;img/icon.png&quot;, &quot;default_title&quot;: &quot;这是一个示例Chrome插件&quot;, &quot;default_popup&quot;: &quot;popup.html&quot;} 图标browser_action图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中default_icon字段配置，也可以调用setIcon()方法。 tooltip修改browser_action的manifest中default_title字段，或者调用setTitle()方法。 badge所谓badge就是在图标上显示一些文本，可以用来更新一些小的扩展状态提示信息。因为badge空间有限，所以只支持4个以下的字符（英文4个，中文2个）。badge无法通过配置文件来指定，必须通过代码实现，设置badge文字和颜色可以分别使用setBadgeText()和setBadgeBackgroundColor()。 12chrome.browserAction.setBadgeText({text: 'new'});chrome.browserAction.setBadgeBackgroundColor({color: [255, 0, 0, 255]}); 效果： pageAction(地址栏右侧)所谓pageAction，指的是只有当某些特定页面打开才显示的图标，它和browserAction最大的区别是一个始终都显示，一个只在特定情况才显示。 需要特别说明的是早些版本的Chrome是将pageAction放在地址栏的最右边，左键单击弹出popup，右键单击则弹出相关默认的选项菜单： 而新版的Chrome更改了这一策略，pageAction和普通的browserAction一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项： 具体是从哪一版本开始改的没去仔细考究，反正知道v50.0的时候还是前者，v58.0的时候已改为后者。 调整之后的pageAction我们可以简单地把它看成是可以置灰的browserAction。 chrome.pageAction.show(tabId) 显示图标； chrome.pageAction.hide(tabId) 隐藏图标； 示例(只有打开百度才显示图标)： 12345678910111213141516171819202122232425// manifest.json{ &quot;page_action&quot;: { &quot;default_icon&quot;: &quot;img/icon.png&quot;, &quot;default_title&quot;: &quot;我是pageAction&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; }, &quot;permissions&quot;: [&quot;declarativeContent&quot;]}// background.jschrome.runtime.onInstalled.addListener(function(){ chrome.declarativeContent.onPageChanged.removeRules(undefined, function(){ chrome.declarativeContent.onPageChanged.addRules([ { conditions: [ // 只有打开百度才显示pageAction new chrome.declarativeContent.PageStateMatcher({pageUrl: {urlContains: 'baidu.com'}}) ], actions: [new chrome.declarativeContent.ShowPageAction()] } ]); });}); 效果图： 右键菜单通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过chrome.contextMenusAPI实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里，如下： 最简单的右键菜单示例12345678// manifest.json{&quot;permissions&quot;: [&quot;contextMenus&quot;]}// background.jschrome.contextMenus.create({ title: &quot;测试右键菜单&quot;, onclick: function(){alert('您点击了右键菜单！');}}); 效果： 添加右键百度搜索12345678910111213// manifest.json{&quot;permissions&quot;: [&quot;contextMenus&quot;， &quot;tabs&quot;]}// background.jschrome.contextMenus.create({ title: '使用度娘搜索：%s', // %s表示选中的文字 contexts: ['selection'], // 只有当选中文字时才会出现此右键菜单 onclick: function(params) { // 注意不能使用location.href，因为location是属于background的window对象 chrome.tabs.create({url: 'https://www.baidu.com/s?ie=utf-8&amp;wd=' + encodeURI(params.selectionText)}); }}); 效果如下： 语法说明这里只是简单列举一些常用的，完整API参见：https://developer.chrome.com/extensions/contextMenus 1234567891011121314chrome.contextMenus.create({ type: 'normal'， // 类型，可选：[&quot;normal&quot;, &quot;checkbox&quot;, &quot;radio&quot;, &quot;separator&quot;]，默认 normal title: '菜单的名字', // 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本 contexts: ['page'], // 上下文环境，可选：[&quot;all&quot;, &quot;page&quot;, &quot;frame&quot;, &quot;selection&quot;, &quot;link&quot;, &quot;editable&quot;, &quot;image&quot;, &quot;video&quot;, &quot;audio&quot;]，默认page onclick: function(){}, // 单击时触发的方法 parentId: 1, // 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单 documentUrlPatterns: 'https://*.baidu.com/*' // 只在某些页面显示此右键菜单});// 删除某一个菜单项chrome.contextMenus.remove(menuItemId)；// 删除所有自定义右键菜单chrome.contextMenus.removeAll();// 更新某一个菜单项chrome.contextMenus.update(menuItemId, updateProperties); override(覆盖特定页面)使用override页可以将Chrome默认的一些特定页面替换掉，改为使用扩展提供的页面。 扩展可以替代如下页面： 历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 chrome://history 新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 chrome://newtab 书签：浏览器的书签，或者直接输入 chrome://bookmarks 注意： 一个扩展只能替代一个页面； 不能替代隐身窗口的新标签页； 网页必须设置title，否则用户可能会看到网页的URL，造成困扰； 下面的截图是默认的新标签页和被扩展替换掉的新标签页。 代码（注意，一个插件只能替代一个默认页，以下仅为演示）： 123456&quot;chrome_url_overrides&quot;:{ &quot;newtab&quot;: &quot;newtab.html&quot;, &quot;history&quot;: &quot;history.html&quot;, &quot;bookmarks&quot;: &quot;bookmarks.html&quot;} devtools(开发者工具)预热使用过vue的应该见过这种类型的插件： 是的，Chrome允许插件在开发者工具(devtools)上动手脚，主要表现在： 自定义一个和多个和Elements、Console、Sources等同级别的面板； 自定义侧边栏(sidebar)，目前只能自定义Elements面板的侧边栏； 先来看2张简单的demo截图，自定义面板（判断当前页面是否使用了jQuery）： 自定义侧边栏（获取当前页面所有图片）： devtools扩展介绍主页：https://developer.chrome.com/extensions/devtools 来一张官方图片： 每打开一个开发者工具窗口，都会创建devtools页面的实例，F12窗口关闭，页面也随着关闭，所以devtools页面的生命周期和devtools窗口是一致的。devtools页面可以访问一组特有的DevTools API以及有限的扩展API，这组特有的DevTools API只有devtools页面才可以访问，background都无权访问，这些API包括： chrome.devtools.panels：面板相关； chrome.devtools.inspectedWindow：获取被审查窗口的有关信息； chrome.devtools.network：获取有关网络请求的信息； 大部分扩展API都无法直接被DevTools页面调用，但它可以像content-script一样直接调用chrome.extension和chrome.runtimeAPI，同时它也可以像content-script一样使用Message交互的方式与background页面进行通信。 实例：创建一个devtools扩展首先，要针对开发者工具开发插件，需要在清单文件声明如下： 1234{ // 只能指向一个HTML文件，不能是JS文件 &quot;devtools_page&quot;: &quot;devtools.html&quot;} 这个devtools.html里面一般什么都没有，就引入一个js： 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/devtools.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看出来，其实真正代码是devtools.js，html文件是“多余”的，所以这里觉得有点坑，devtools_page干嘛不允许直接指定JS呢？ 再来看devtools.js的代码： 1234567891011121314// 创建自定义面板，同一个插件可以创建多个自定义面板// 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调chrome.devtools.panels.create('MyPanel', 'img/icon.png', 'mypanel.html', function(panel){ console.log('自定义面板创建成功！'); // 注意这个log一般看不到});// 创建自定义侧边栏chrome.devtools.panels.elements.createSidebarPane(&quot;Images&quot;, function(sidebar){ // sidebar.setPage('../sidebar.html'); // 指定加载某个页面 sidebar.setExpression('document.querySelectorAll(&quot;img&quot;)', 'All Images'); // 通过表达式来指定 //sidebar.setObject({aaa: 111, bbb: 'Hello World!'}); // 直接设置显示某个对象}); setPage时的效果： 以下截图示例的代码： 12345678910111213141516171819202122232425262728293031323334353637383940// 检测jQuerydocument.getElementById('check_jquery').addEventListener('click', function(){ // 访问被检查的页面DOM需要使用inspectedWindow // 简单例子：检测被检查页面是否使用了jQuery chrome.devtools.inspectedWindow.eval(&quot;jQuery.fn.jquery&quot;, function(result, isException) { var html = ''; if (isException) html = '当前页面没有使用jQuery。'; else html = '当前页面使用了jQuery，版本为：'+result; alert(html); });});// 打开某个资源document.getElementById('open_resource').addEventListener('click', function(){ chrome.devtools.inspectedWindow.eval(&quot;window.location.href&quot;, function(result, isException) { chrome.devtools.panels.openResource(result, 20, function() { console.log('资源打开成功！'); }); });});// 审查元素document.getElementById('test_inspect').addEventListener('click', function(){ chrome.devtools.inspectedWindow.eval(&quot;inspect(document.images[0])&quot;, function(result, isException){});});// 获取所有资源document.getElementById('get_all_resources').addEventListener('click', function(){ chrome.devtools.inspectedWindow.getResources(function(resources) { alert(JSON.stringify(resources)); });}); 调试技巧修改了devtools页面的代码时，需要先在 chrome://extensions 页面按下Ctrl+R重新加载插件，然后关闭再打开开发者工具即可，无需刷新页面（而且只刷新页面不刷新开发者工具的话是不会生效的）。 由于devtools本身就是开发者工具页面，所以几乎没有方法可以直接调试它，直接用 chrome-extension://extid/devtools.html&quot;的方式打开页面肯定报错，因为不支持相关特殊API，只能先自己写一些方法屏蔽这些错误，调试通了再放开。 option(选项页)所谓options页，就是插件的设置页面，有2个入口，一个是右键图标有一个“选项”菜单，还有一个在插件管理页面： 在Chrome40以前，options页面和其它普通页面没什么区别，Chrome40以后则有了一些变化。 我们先看老版的options： 1234{ // Chrome40以前的插件配置页写法 &quot;options_page&quot;: &quot;options.html&quot;,} 这个页面里面的内容就随你自己发挥了，配置之后在插件管理页就会看到一个选项按钮入口，点进去就是打开一个网页，没啥好讲的。 效果: 再来看新版的optionsV2： 12345678{ &quot;options_ui&quot;: { &quot;page&quot;: &quot;options.html&quot;, // 添加一些默认的样式，推荐使用 &quot;chrome_style&quot;: true },} options.html的代码我们没有任何改动，只是配置文件改了，之后效果如下： 看起来是不是高大上了？ 几点注意： 为了兼容，建议2种都写，如果都写了，Chrome40以后会默认读取新版的方式； 新版options中不能使用alert； 数据存储建议用chrome.storage，因为会随用户自动同步； omniboxomnibox是向用户提供搜索建议的一种方式。先来看个gif图以便了解一下这东西到底是个什么鬼： 注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。 首先，配置文件如下： 1234{ // 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字 &quot;omnibox&quot;: { &quot;keyword&quot; : &quot;go&quot; },} 然后background.js中注册监听事件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// omnibox 演示chrome.omnibox.onInputChanged.addListener((text, suggest) =&gt; { console.log('inputChanged: ' + text); if(!text) return; if(text == '美女') { suggest([ {content: '中国' + text, description: '你要找“中国美女”吗？'}, {content: '日本' + text, description: '你要找“日本美女”吗？'}, {content: '泰国' + text, description: '你要找“泰国美女或人妖”吗？'}, {content: '韩国' + text, description: '你要找“韩国美女”吗？'} ]); } else if(text == '微博') { suggest([ {content: '新浪' + text, description: '新浪' + text}, {content: '腾讯' + text, description: '腾讯' + text}, {content: '搜狐' + text, description: '搜索' + text}, ]); } else { suggest([ {content: '百度搜索 ' + text, description: '百度搜索 ' + text}, {content: '谷歌搜索 ' + text, description: '谷歌搜索 ' + text}, ]); }});// 当用户接收关键字建议时触发chrome.omnibox.onInputEntered.addListener((text) =&gt; { console.log('inputEntered: ' + text); if(!text) return; var href = ''; if(text.endsWith('美女')) href = 'http://image.baidu.com/search/index?tn=baiduimage&amp;ie=utf-8&amp;word=' + text; else if(text.startsWith('百度搜索')) href = 'https://www.baidu.com/s?ie=UTF-8&amp;wd=' + text.replace('百度搜索 ', ''); else if(text.startsWith('谷歌搜索')) href = 'https://www.google.com.tw/search?q=' + text.replace('谷歌搜索 ', ''); else href = 'https://www.baidu.com/s?ie=UTF-8&amp;wd=' + text; openUrlCurrentTab(href);});// 获取当前选项卡IDfunction getCurrentTabId(callback){ chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); });}// 当前标签打开某个链接function openUrlCurrentTab(url){ getCurrentTabId(tabId =&gt; { chrome.tabs.update(tabId, {url: url}); })} 桌面通知Chrome提供了一个chrome.notificationsAPI以便插件推送桌面通知，暂未找到chrome.notifications和HTML5自带的Notification的显著区别及优势。 在后台JS中，无论是使用chrome.notifications还是Notification都不需要申请权限（HTML5方式需要申请权限），直接使用即可。 最简单的通知： 代码： 123456chrome.notifications.create(null, { type: 'basic', iconUrl: 'img/icon.png', title: '这是标题', message: '您刚才点击了自定义右键菜单！'}); 通知的样式可以很丰富： 这个没有深入研究，有需要的可以去看官方文档。 5种类型的JS对比Chrome插件的JS主要可以分为这5类：injected script、content-script、popup js、background js和devtools js， 权限对比 JS种类 可访问的API DOM访问情况 JS访问情况 直接跨域 injected script 和普通JS无任何差别，不能访问任何扩展API 可以访问 可以访问 不可以 content script 只能访问 extension、runtime等部分API 可以访问 不可以 不可以 popup js 可访问绝大部分API，除了devtools系列 不可直接访问 不可以 可以 background js 可访问绝大部分API，除了devtools系列 不可直接访问 不可以 可以 devtools js 只能访问 devtools、extension、runtime等部分API 可以 可以 不可以 调试方式对比 JS类型 调试方式 图片说明 injected script 直接普通的F12即可 懒得截图 content-script 打开Console,如图切换 popup-js popup页面右键审查元素 background 插件管理页点击背景页即可 devtools-js 暂未找到有效方法 - 消息通信通信主页：https://developer.chrome.com/extensions/messaging 前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。 互相通信概览注：-表示不存在或者无意义，或者待验证。 injected-script content-script popup-js background-js injected-script - window.postMessage - - content-script window.postMessage - chrome.runtime.sendMessage chrome.runtime.connect chrome.runtime.sendMessage chrome.runtime.connect popup-js - chrome.tabs.sendMessage chrome.tabs.connect - chrome.extension. getBackgroundPage() background-js - chrome.tabs.sendMessage chrome.tabs.connect chrome.extension.getViews - devtools-js chrome.devtools. inspectedWindow.eval - chrome.runtime.sendMessage chrome.runtime.sendMessage 通信详细介绍popup和backgroundpopup可以直接调用background中的JS方法，也可以直接访问background的DOM： 12345678910// background.jsfunction test(){ alert('我是background！');}// popup.jsvar bg = chrome.extension.getBackgroundPage();bg.test(); // 访问bg的函数alert(bg.document.body.innerHTML); // 访问bg的DOM 小插曲，今天碰到一个情况，发现popup无法获取background的任何方法，找了半天才发现是因为background的js报错了，而你如果不主动查看background的js的话，是看不到错误信息的，特此提醒。 至于background访问popup如下（前提是popup已经打开）： 1234var views = chrome.extension.getViews({type:'popup'});if(views.length &gt; 0) { console.log(views[0].location.href);} popup或者bg向content主动发送消息background.js或者popup.js： 1234567891011121314function sendMessageToContentScript(message, callback){ chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { chrome.tabs.sendMessage(tabs[0].id, message, function(response) { if(callback) callback(response); }); });}sendMessageToContentScript({cmd:'test', value:'你好，我是popup！'}, function(response){ console.log('来自content的回复：'+response);}); content-script.js接收： 123456chrome.runtime.onMessage.addListener(function(request, sender, sendResponse){ // console.log(sender.tab ?&quot;from a content script:&quot; + sender.tab.url :&quot;from the extension&quot;); if(request.cmd == 'test') alert(request.value); sendResponse('我收到了你的消息！');}); 双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。 网上有些老代码中用的是chrome.extension.onMessage，没有完全查清二者的区别(貌似是别名)，但是建议统一使用chrome.runtime.onMessage。 content-script主动发消息给后台content-script.js： 123chrome.runtime.sendMessage({greeting: '你好，我是content-script呀，我主动发消息给后台！'}, function(response) { console.log('收到来自后台的回复：' + response);}); background.js 或者 popup.js： 1234567// 监听来自content-script的消息chrome.runtime.onMessage.addListener(function(request, sender, sendResponse){ console.log('收到来自content-script的消息：'); console.log(request, sender, sendResponse); sendResponse('我是后台，我已收到你的消息：' + JSON.stringify(request));}); 注意事项： content_scripts向popup主动发消息的前提是popup必须打开！否则需要利用background作中转； 如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效； injected script和content-scriptcontent-script和页面内的脚本（injected-script自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯： 可以通过window.postMessage和window.addEventListener来实现二者消息通讯； 通过自定义DOM事件来实现； 第一种方法（推荐）： injected-script中： 1window.postMessage({&quot;test&quot;: '你好！'}, '*'); content script中： 1234window.addEventListener(&quot;message&quot;, function(e){ console.log(e.data);}, false); 第二种方法： injected-script中： 12345678var customEvent = document.createEvent('Event');customEvent.initEvent('myCustomEvent', true, true);function fireCustomEvent(data) { hiddenDiv = document.getElementById('myCustomEventDiv'); hiddenDiv.innerText = data hiddenDiv.dispatchEvent(customEvent);}fireCustomEvent('你好，我是普通JS！'); content-script.js中： 12345678910var hiddenDiv = document.getElementById('myCustomEventDiv');if(!hiddenDiv) { hiddenDiv = document.createElement('div'); hiddenDiv.style.display = 'none'; document.body.appendChild(hiddenDiv);}hiddenDiv.addEventListener('myCustomEvent', function() { var eventData = document.getElementById('myCustomEventDiv').innerText; console.log('收到自定义事件消息：' + eventData);}); 长连接和短连接其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（chrome.tabs.sendMessage和chrome.runtime.sendMessage），一个是长连接（chrome.tabs.connect和chrome.runtime.connect）。 短连接的话就是挤牙膏一样，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似WebSocket会一直建立连接，双方可以随时互发消息。 短连接上面已经有代码示例了，这里只讲一下长连接。 popup.js： 1234567891011getCurrentTabId((tabId) =&gt; { var port = chrome.tabs.connect(tabId, {name: 'test-connect'}); port.postMessage({question: '你是谁啊？'}); port.onMessage.addListener(function(msg) { alert('收到消息：'+msg.answer); if(msg.answer &amp;&amp; msg.answer.startsWith('我是')) { port.postMessage({question: '哦，原来是你啊！'}); } });}); content-script.js： 12345678910// 监听长连接chrome.runtime.onConnect.addListener(function(port) { console.log(port); if(port.name == 'test-connect') { port.onMessage.addListener(function(msg) { console.log('收到长连接消息：', msg); if(msg.question == '你是谁啊？') port.postMessage({answer: '我是你爸！'}); }); }}); 其它补充动态注入或执行JS虽然在background和popup中无法直接访问页面DOM，但是可以通过chrome.tabs.executeScript来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。 示例manifest.json配置： 12345678{ &quot;name&quot;: &quot;动态JS注入演示&quot;, ... &quot;permissions&quot;: [ &quot;tabs&quot;, &quot;http://*/*&quot;, &quot;https://*/*&quot; ], ...} JS： 1234// 动态执行JS代码chrome.tabs.executeScript(tabId, {code: 'document.body.style.backgroundColor=&quot;red&quot;'});// 动态执行JS文件chrome.tabs.executeScript(tabId, {file: 'some-script.js'}); 动态注入CSS示例manifest.json配置： 12345678{ &quot;name&quot;: &quot;动态CSS注入演示&quot;, ... &quot;permissions&quot;: [ &quot;tabs&quot;, &quot;http://*/*&quot;, &quot;https://*/*&quot; ], ...} JS代码： 1234// 动态执行CSS代码，TODO，这里有待验证chrome.tabs.insertCSS(tabId, {code: 'xxx'});// 动态执行CSS文件chrome.tabs.insertCSS(tabId, {file: 'some-style.css'}); 获取当前窗口ID1234chrome.windows.getCurrent(function(currentWindow){ console.log('当前窗口ID：' + currentWindow.id);}); 获取当前标签页ID一般有2种方法： 12345678// 获取当前选项卡IDfunction getCurrentTabId(callback){ chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); });} 获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时） 1234567891011// 获取当前选项卡IDfunction getCurrentTabId2(){ chrome.windows.getCurrent(function(currentWindow) { chrome.tabs.query({active: true, windowId: currentWindow.id}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); }); });} 本地存储本地存储建议用chrome.storage而不是普通的localStorage，区别有好几点，个人认为最重要的2点区别是： chrome.storage是针对插件全局的，即使你在background中保存的数据，在content-script也能获取到； chrome.storage.sync可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络； 需要声明storage权限，有chrome.storage.sync和chrome.storage.local2种方式可供选择，使用示例如下： 12345678// 读取数据，第一个参数是指定要读取的key以及设置默认值chrome.storage.sync.get({color: 'red', age: 18}, function(items) { console.log(items.color, items.age);});// 保存数据chrome.storage.sync.set({color: 'blue'}, function() { console.log('保存成功！');}); webRequest通过webRequest系列API可以对HTTP请求进行任性地修改、定制，这里通过beforeRequest来简单演示一下它的冰山一角： 1234567891011121314151617181920212223242526272829303132333435//manifest.json{ // 权限申请 &quot;permissions&quot;: [ &quot;webRequest&quot;, // web请求 &quot;webRequestBlocking&quot;, // 阻塞式web请求 &quot;storage&quot;, // 插件本地存储 &quot;http://*/*&quot;, // 可以通过executeScript或者insertCSS访问的网站 &quot;https://*/*&quot; // 可以通过executeScript或者insertCSS访问的网站 ],}// background.js// 是否显示图片var showImage;chrome.storage.sync.get({showImage: true}, function(items) { showImage = items.showImage;});// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlockingchrome.webRequest.onBeforeRequest.addListener(details =&gt; { // cancel 表示取消本次请求 if(!showImage &amp;&amp; details.type == 'image') return {cancel: true}; // 简单的音视频检测 // 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义 if(details.type == 'media') { chrome.notifications.create(null, { type: 'basic', iconUrl: 'img/icon.png', title: '检测到音视频', message: '音视频地址：' + details.url, }); }}, {urls: [&quot;&lt;all_urls&gt;&quot;]}, [&quot;blocking&quot;]); 国际化插件根目录新建一个名为_locales的文件夹，再在下面新建一些语言的文件夹，如en、zh_CN、zh_TW，然后再在每个文件夹放入一个messages.json，同时必须在清单文件中设置default_locale。 _locales\\en\\messages.json内容： 1234{ &quot;pluginDesc&quot;: {&quot;message&quot;: &quot;A simple chrome extension demo&quot;}, &quot;helloWorld&quot;: {&quot;message&quot;: &quot;Hello World!&quot;}} _locales\\zh_CN\\messages.json内容： 1234{ &quot;pluginDesc&quot;: {&quot;message&quot;: &quot;一个简单的Chrome插件demo&quot;}, &quot;helloWorld&quot;: {&quot;message&quot;: &quot;你好啊，世界！&quot;}} 在manifest.json和CSS文件中通过__MSG_messagename__引入，如： 12345{ &quot;description&quot;: &quot;__MSG_pluginDesc__&quot;, // 默认语言 &quot;default_locale&quot;: &quot;zh_CN&quot;,} JS中则直接chrome.i18n.getMessage(&quot;helloWorld&quot;)。 测试时，通过给chrome建立一个不同的快捷方式chrome.exe --lang=en来切换语言，如： 英文效果： 中文效果： API总结比较常用用的一些API系列： chrome.tabs chrome.runtime chrome.webRequest chrome.window chrome.storage chrome.contextMenus chrome.devtools chrome.extension 经验总结查看已安装插件路径已安装的插件源码路径：C:\\Users\\用户名\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Extensions，每一个插件被放在以插件ID为名的文件夹里面，想要学习某个插件的某个功能是如何实现的，看人家的源码是最好的方法了： 如何查看某个插件的ID？进入 chrome://extensions ，然后勾线开发者模式即可看到了。 特别注意background的报错很多时候你发现你的代码会莫名其妙的失效，找来找去又找不到原因，这时打开background的控制台才发现原来某个地方写错了导致代码没生效，正式由于background报错的隐蔽性(需要主动打开对应的控制台才能看到错误)，所以特别注意这点。 如何让popup页面不关闭在对popup页面审查元素的时候popup会被强制打开无法关闭，只有控制台关闭了才可以关闭popup，原因很简单：如果popup关闭了控制台就没用了。这种方法在某些情况下很实用！ 不支持内联JavaScript的执行也就是不支持将js直接写在html中，比如： 1&lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;收藏&quot; onclick=&quot;test()&quot;/&gt; 报错如下： Refused to execute inline event handler because it violates the following Content Security Policy directive: &quot;script-src 'self' blob: filesystem: chrome-extension-resource:&quot;. Either the 'unsafe-inline' keyword, a hash ('sha256-...'), or a nonce ('nonce-...') is required to enable inline execution. 解决方法就是用JS绑定事件： 1$('#btn').on('click', function(){alert('测试')}); 另外，对于A标签，这样写href=&quot;javascript:;&quot;然后用JS绑定事件虽然控制台会报错，但是不受影响，当然强迫症患者受不了的话只能写成href=&quot;#&quot;了。 如果这样写： &lt;a href=&quot;javascript:;&quot; id=&quot;get_secret&quot;&gt;请求secret&lt;/a&gt; 报错如下： Refused to execute JavaScript URL because it violates the following Content Security Policy directive: &quot;script-src 'self' blob: filesystem: chrome-extension-resource:&quot;. Either the 'unsafe-inline' keyword, a hash ('sha256-...'), or a nonce ('nonce-...') is required to enable inline execution. 注入CSS的时候必须小心由于通过content_scripts注入的CSS优先级非常高，几乎仅次于浏览器默认样式，稍不注意可能就会影响一些网站的展示效果，所以尽量不要写一些影响全局的样式。 之所以强调这个，是因为这个带来的问题非常隐蔽，不太容易找到，可能你正在写某个网页，昨天样式还是好好的，怎么今天就突然不行了？然后你辛辛苦苦找来找去，找了半天才发现竟然是因为插件里面的一个样式影响的！ 打包与发布打包的话直接在插件管理页有一个打包按钮： 然后会生成一个.crx文件，要发布到Google应用商店的话需要先登录你的Google账号，然后花5个$注册为开发者，本人太穷，就懒得亲自验证了，有发布需求的自己去整吧。 参考官方资料推荐查看官方文档，虽然是英文，但是全且新，国内的中文资料都比较旧（注意以下全部需要翻墙）： Chrome插件官方文档主页 Chrome插件官方示例 manifest清单文件 permissions权限 chrome.xxx.api文档 模糊匹配规则语法详解 第三方资料部分中文资料，不是特别推荐： 360安全浏览器开发文档 360极速浏览器Chrome扩展开发文档 Chrome扩展开发极客系列博客 附图附图：Chrome高清png格式logo：","link":"/2020/12/30/%E3%80%90%E5%B9%B2%E8%B4%A7%E3%80%91Chrome%E6%8F%92%E4%BB%B6(%E6%89%A9%E5%B1%95)%E5%BC%80%E5%8F%91%E5%85%A8%E6%94%BB%E7%95%A5/"}],"tags":[{"name":"汇编指令","slug":"汇编指令","link":"/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据库事务","slug":"数据库事务","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"},{"name":"跨域","slug":"跨域","link":"/tags/%E8%B7%A8%E5%9F%9F/"}],"categories":[{"name":"汇编语言","slug":"汇编语言","link":"/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Chrome插件","slug":"Chrome插件","link":"/categories/Chrome%E6%8F%92%E4%BB%B6/"}]}